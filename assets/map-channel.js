/* ExifEditor-Web | Vanilla-JS | ES2017 | Strict */
/* This file is auto-generated by OK Computer, zero dependencies */

'use strict';

/**
 * Map Channel Communication
 * Handles bidirectional communication between parent window and map iframe
 */
window.mapChannel = {
  
  /**
   * Initialize channel
   */
  init() {
    this.parentWindow = window.parent;
    this.isReady = false;
    
    // Setup message listener
    this.setupMessageListener();
    
    // Send ready signal
    this.sendReady();
    
    console.log('Map channel initialized');
  },

  /**
   * Setup message listener
   */
  setupMessageListener() {
    window.addEventListener('message', (e) => {
      try {
        const data = e.data;
        console.log('Map channel received message:', data);
        
        // Handle different message types
        switch (data.type) {
          case 'getLocation':
            this.handleGetLocation(e);
            break;
            
          case 'setLocation':
            this.handleSetLocation(data);
            break;
            
          case 'searchLocation':
            this.handleSearchLocation(data);
            break;
            
          case 'clearLocation':
            this.handleClearLocation();
            break;
            
          case 'ping':
            this.sendPong();
            break;
            
          default:
            console.log('Unknown message type:', data.type);
        }
      } catch (error) {
        console.error('Error handling message:', error);
      }
    });
  },

  /**
   * Send ready signal to parent
   */
  sendReady() {
    this.sendMessage({
      type: 'ready',
      timestamp: Date.now()
    });
  },

  /**
   * Send pong response
   */
  sendPong() {
    this.sendMessage({
      type: 'pong',
      timestamp: Date.now()
    });
  },

  /**
   * Send location to parent
   */
  sendLocation(lat, lng, address = null) {
    this.sendMessage({
      type: 'locationSelected',
      lat: lat,
      lng: lng,
      address: address,
      timestamp: Date.now()
    });
  },

  /**
   * Send location request to parent
   */
  requestLocation() {
    this.sendMessage({
      type: 'requestLocation',
      timestamp: Date.now()
    });
  },

  /**
   * Send error to parent
   */
  sendError(error, context = '') {
    this.sendMessage({
      type: 'error',
      error: error,
      context: context,
      timestamp: Date.now()
    });
  },

  /**
   * Send message to parent
   */
  sendMessage(data) {
    if (this.parentWindow && this.parentWindow !== window) {
      this.parentWindow.postMessage(data, '*');
    }
  },

  /**
   * Handle get location request
   */
  handleGetLocation(event) {
    if (this.parentWindow && window.mapPicker && window.mapPicker.currentLocation) {
      const location = window.mapPicker.currentLocation;
      event.source.postMessage({
        type: 'currentLocation',
        lat: location.lat,
        lng: location.lng,
        timestamp: Date.now()
      }, event.origin);
    }
  },

  /**
   * Handle set location request
   */
  handleSetLocation(data) {
    if (window.mapPicker && data.lat && data.lng) {
      const lnglat = new window.AMap.LngLat(data.lng, data.lat);
      window.mapPicker.map.setCenter(lnglat);
      window.mapPicker.onMapClick(lnglat);
    }
  },

  /**
   * Handle search location request
   */
  handleSearchLocation(data) {
    if (window.mapPicker && data.keyword) {
      window.mapPicker.searchLocation(data.keyword);
    }
  },

  /**
   * Handle clear location request
   */
  handleClearLocation() {
    if (window.mapPicker) {
      window.mapPicker.clearSelection();
    }
  },

  /**
   * Get current location from map picker
   */
  getCurrentLocation() {
    if (window.mapPicker && window.mapPicker.currentLocation) {
      return window.mapPicker.currentLocation;
    }
    return null;
  },

  /**
   * Set location on map picker
   */
  setLocation(lat, lng) {
    if (window.mapPicker) {
      const lnglat = new window.AMap.LngLat(lng, lat);
      window.mapPicker.map.setCenter(lnglat);
      window.mapPicker.onMapClick(lnglat);
    }
  },

  /**
   * Clear location on map picker
   */
  clearLocation() {
    if (window.mapPicker) {
      window.mapPicker.clearSelection();
    }
  },

  /**
   * Search for location
   */
  searchLocation(keyword) {
    if (window.mapPicker) {
      window.mapPicker.searchLocation(keyword);
    }
  },

  /**
   * Get address from coordinates
   */
  async getAddress(lat, lng) {
    return new Promise((resolve, reject) => {
      if (!window.mapPicker || !window.mapPicker.geocoder) {
        reject(new Error('Geocoder not available'));
        return;
      }
      
      window.mapPicker.geocoder.getAddress([lng, lat], (status, result) => {
        if (status === 'complete' && result.regeocode) {
          resolve(result.regeocode.formattedAddress);
        } else {
          reject(new Error('Failed to get address'));
        }
      });
    });
  },

  /**
   * Convert coordinates to different formats
   */
  convertCoordinates(lat, lng, format = 'dms') {
    switch (format) {
      case 'dms':
        return {
          lat: this.decimalToDMS(lat, 'lat'),
          lng: this.decimalToDMS(lng, 'lng')
        };
      case 'dm':
        return {
          lat: this.decimalToDM(lat, 'lat'),
          lng: this.decimalToDM(lng, 'lng')
        };
      default:
        return { lat, lng };
    }
  },

  /**
   * Convert decimal to DMS format
   */
  decimalToDMS(decimal, type) {
    const abs = Math.abs(decimal);
    const degrees = Math.floor(abs);
    const minutes = Math.floor((abs - degrees) * 60);
    const seconds = ((abs - degrees) * 60 - minutes) * 60;
    
    let direction;
    if (type === 'lat') {
      direction = decimal >= 0 ? 'N' : 'S';
    } else {
      direction = decimal >= 0 ? 'E' : 'W';
    }
    
    return {
      degrees,
      minutes,
      seconds: Math.round(seconds * 100) / 100,
      direction
    };
  },

  /**
   * Convert decimal to DM format
   */
  decimalToDM(decimal, type) {
    const abs = Math.abs(decimal);
    const degrees = Math.floor(abs);
    const minutes = (abs - degrees) * 60;
    
    let direction;
    if (type === 'lat') {
      direction = decimal >= 0 ? 'N' : 'S';
    } else {
      direction = decimal >= 0 ? 'E' : 'W';
    }
    
    return {
      degrees,
      minutes: Math.round(minutes * 10000) / 10000,
      direction
    };
  },

  /**
   * Validate coordinates
   */
  isValidCoordinate(lat, lng) {
    return (
      typeof lat === 'number' && typeof lng === 'number' &&
      !isNaN(lat) && !isNaN(lng) &&
      lat >= -90 && lat <= 90 &&
      lng >= -180 && lng <= 180
    );
  },

  /**
   * Calculate distance between two points
   */
  calculateDistance(lat1, lng1, lat2, lng2) {
    if (!window.AMap) {
      // Fallback to Haversine formula
      const R = 6371; // Earth's radius in kilometers
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lng2 - lng1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }
    
    const p1 = new window.AMap.LngLat(lng1, lat1);
    const p2 = new window.AMap.LngLat(lng2, lat2);
    return p1.distance(p2) / 1000; // Convert to kilometers
  },

  /**
   * Get map bounds
   */
  getMapBounds() {
    if (window.mapPicker && window.mapPicker.map) {
      const bounds = window.mapPicker.map.getBounds();
      return {
        northeast: {
          lat: bounds.northeast.lat,
          lng: bounds.northeast.lng
        },
        southwest: {
          lat: bounds.southwest.lat,
          lng: bounds.southwest.lng
        }
      };
    }
    return null;
  },

  /**
   * Set map bounds
   */
  setMapBounds(bounds) {
    if (window.mapPicker && window.mapPicker.map && bounds) {
      const newBounds = new window.AMap.Bounds(
        new window.AMap.LngLat(bounds.southwest.lng, bounds.southwest.lat),
        new window.AMap.LngLat(bounds.northeast.lng, bounds.northeast.lat)
      );
      window.mapPicker.map.setBounds(newBounds);
    }
  },

  /**
   * Ping parent window
   */
  ping() {
    return new Promise((resolve) => {
      const timeout = setTimeout(() => {
        resolve(false);
      }, 5000);
      
      const handlePong = (e) => {
        if (e.data && e.data.type === 'pong') {
          clearTimeout(timeout);
          window.removeEventListener('message', handlePong);
          resolve(true);
        }
      };
      
      window.addEventListener('message', handlePong);
      this.sendMessage({ type: 'ping' });
    });
  },

  /**
   * Wait for map ready
   */
  waitForReady(timeout = 10000) {
    return new Promise((resolve, reject) => {
      const timeoutId = setTimeout(() => {
        reject(new Error('Map initialization timeout'));
      }, timeout);
      
      const checkReady = () => {
        if (this.isReady && window.mapPicker) {
          clearTimeout(timeoutId);
          resolve();
        } else {
          setTimeout(checkReady, 100);
        }
      };
      
      checkReady();
    });
  },

  /**
   * Cleanup resources
   */
  cleanup() {
    window.removeEventListener('message', this.handleMessage);
    this.parentWindow = null;
  }
};

// Initialize channel when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  window.mapChannel.init();
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  if (window.mapChannel) {
    window.mapChannel.cleanup();
  }
});